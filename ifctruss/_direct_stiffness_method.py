# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb.

# %% auto 0
__all__ = ['DirectStiffnessMethodException', 'DirectStiffnessMethod']

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 3
# Copyright Â© 2023-2024  IfcTruss Contributors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 6
from fastcore.basics import patch
import numpy as np
import pandas as pd

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 8
class DirectStiffnessMethodException(Exception):
    pass

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 9
class DirectStiffnessMethod:
    def __init__(
        self,
        *,
        bars,
        nodes,
        point_loads,
    ):
        self.bars = bars
        self.nodes = nodes
        self.point_loads = point_loads

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 15
@patch
def extend_nodes_df(
    self: DirectStiffnessMethod,
):
    self.number_of_rows = self.nodes.shape[0]
    self.dimensions = 3

    self.number_of_degrees_of_freedom = (
        self.number_of_rows * self.dimensions
    )

    self.nodes["Degrees_of_freedom"] = pd.Series(
        np.split(
            np.arange(self.number_of_degrees_of_freedom),
            self.number_of_rows,
        )
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 18
@patch
def extend_bars_df(
    self: DirectStiffnessMethod,
):
    start_node = self.nodes.rename(
        columns={
            "Node": "Start_node",
            "Coordinate_X": "x_1",
            "Coordinate_Y": "y_1",
            "Coordinate_Z": "z_1",
            "Degrees_of_freedom": "Degrees_of_freedom_1",
        }
    )

    bars_start = pd.merge(
        self.bars,
        start_node[
            ["Start_node", "x_1", "y_1", "z_1", "Degrees_of_freedom_1"]
        ],
        on="Start_node",
    )

    end_node = self.nodes.rename(
        columns={
            "Node": "End_node",
            "Coordinate_X": "x_2",
            "Coordinate_Y": "y_2",
            "Coordinate_Z": "z_2",
            "Degrees_of_freedom": "Degrees_of_freedom_2",
        }
    )

    self.bars_extended = pd.merge(
        bars_start,
        end_node[["End_node", "x_2", "y_2", "z_2", "Degrees_of_freedom_2"]],
        on="End_node",
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 22
@patch
def calculate_differences(
    self: DirectStiffnessMethod, x_1, y_1, z_1, x_2, y_2, z_2
):
    l_x = x_2 - x_1
    l_y = y_2 - y_1
    l_z = z_2 - z_1
    return l_x, l_y, l_z

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 24
@patch
def calculate_distance(self: DirectStiffnessMethod, l_x, l_y, l_z):
    vector = np.array([l_x, l_y, l_z])
    l = np.linalg.norm(vector)
    return l

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 26
@patch
def create_element_stiffness_matrice(
    self: DirectStiffnessMethod, E, A, x_1, y_1, z_1, x_2, y_2, z_2
):
    l_x, l_y, l_z = self.calculate_differences(x_1, y_1, z_1, x_2, y_2, z_2)

    l = self.calculate_distance(l_x, l_y, l_z)

    K_e = (E * A / (l**3)) * np.array(
        [
            [
                l_x**2,
                l_x * l_y,
                l_x * l_z,
                -(l_x**2),
                -l_x * l_y,
                -l_x * l_z,
            ],
            [
                l_x * l_y,
                l_y**2,
                l_y * l_z,
                -l_x * l_y,
                -(l_y**2),
                -l_y * l_z,
            ],
            [
                l_x * l_z,
                l_y * l_z,
                l_z**2,
                -l_x * l_z,
                -l_y * l_z,
                -(l_z**2),
            ],
            [
                -(l_x**2),
                -l_x * l_y,
                -l_x * l_z,
                l_x**2,
                l_x * l_y,
                l_x * l_z,
            ],
            [
                -l_x * l_y,
                -(l_y**2),
                -l_y * l_z,
                l_x * l_y,
                l_y**2,
                l_y * l_z,
            ],
            [
                -l_x * l_z,
                -l_y * l_z,
                -(l_z**2),
                l_x * l_z,
                l_y * l_z,
                l_z**2,
            ],
        ]
    )

    return K_e

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 27
@patch
def create_element_stiffness_matrices(
    self: DirectStiffnessMethod,
):
    self.element_stiffness_matrices = [
        (
            name,
            self.create_element_stiffness_matrice(
                E, A, x_1, y_1, z_1, x_2, y_2, z_2
            ),
            np.concatenate((degrees_of_freedom_1, degrees_of_freedom_2)),
        )
        for name, E, A, x_1, y_1, z_1, x_2, y_2, z_2, degrees_of_freedom_1, degrees_of_freedom_2 in zip(
            self.bars_extended["Bar"],
            self.bars_extended["Modulus_of_elasticity"],
            self.bars_extended["Cross-sectional_area"],
            self.bars_extended["x_1"],
            self.bars_extended["y_1"],
            self.bars_extended["z_1"],
            self.bars_extended["x_2"],
            self.bars_extended["y_2"],
            self.bars_extended["z_2"],
            self.bars_extended["Degrees_of_freedom_1"],
            self.bars_extended["Degrees_of_freedom_2"],
        )
    ]

    self.element_stiffness_matrices_df = pd.DataFrame(
        self.element_stiffness_matrices,
        columns=["Bar", "Element_Matrice", "Degrees_of_freedom"],
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 36
@patch
def create_system_stiffness_matrice(
    self: DirectStiffnessMethod,
):
    self.K_f = np.zeros(
        (
            self.number_of_degrees_of_freedom,
            self.number_of_degrees_of_freedom,
        )
    )

    for element_matrice, degrees_of_freedom in zip(
        self.element_stiffness_matrices_df["Element_Matrice"],
        self.element_stiffness_matrices_df["Degrees_of_freedom"],
    ):
        for idx_horizontal, idx_vertical, value in zip(
            np.repeat(degrees_of_freedom, len(degrees_of_freedom)),
            np.tile(degrees_of_freedom, len(degrees_of_freedom)),
            element_matrice.flat,
        ):
            self.K_f[idx_horizontal, idx_vertical] += value

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 41
@patch
def create_force_vector(
    self: DirectStiffnessMethod,
):
    self.F_f = np.zeros(self.number_of_degrees_of_freedom)

    self.point_loads_extended = pd.merge(
        self.point_loads,
        self.nodes[["Node", "Degrees_of_freedom"]],
        on="Node",
    )

    np.add.at(
        self.F_f,
        np.concatenate(
            self.point_loads_extended["Degrees_of_freedom"].values
        ),
        np.concatenate(
            self.point_loads_extended[
                ["Force_X", "Force_Y", "Force_Z"]
            ].values
        ),
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 58
@patch
def create_reduced_system_stiffness_matrice_and_reduced_force_vector(
    self: DirectStiffnessMethod,
):
    self.translationals = np.logical_not(
        self.nodes[
            [
                "Translational_X",
                "Translational_Y",
                "Translational_Z",
            ]
        ].values.flatten()
    )
    self.K_f_reduced = self.K_f[:, self.translationals][self.translationals]
    self.F_f_reduced = self.F_f[self.translationals]

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 65
@patch
def calculate_displacement_vector(
    self: DirectStiffnessMethod,
):
    try:
        self.u_f_reduced = (
            np.linalg.inv(self.K_f_reduced) @ self.F_f_reduced
        )
    except np.linalg.LinAlgError as l:
        if str(l) == "Singular matrix":
            raise DirectStiffnessMethodException(
                "Mechanism - The system is unstable"
            )
        else:
            raise l

    self.degrees_of_freedom = np.concatenate(
        self.nodes[
            [
                "Degrees_of_freedom",
            ]
        ].values.flatten()
    )
    self.u_f = np.zeros(
        self.number_of_rows * self.dimensions,
    )

    self.u_f[self.translationals] = self.u_f_reduced

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 70
@patch
def calculate_force_vector(
    self: DirectStiffnessMethod,
):
    self.F_f_calculated = self.K_f @ self.u_f

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 74
@patch
def correct_force_vector(
    self: DirectStiffnessMethod,
):
    self.F_f_nodes = self.F_f.copy()
    self.F_f_nodes[self.translationals] = 0

    self.F_f_corrected = self.F_f_calculated - self.F_f_nodes

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 83
@patch
def create_internal_force_matrice(
    self: DirectStiffnessMethod, E, A, x_1, y_1, z_1, x_2, y_2, z_2
):
    l_x, l_y, l_z = self.calculate_differences(x_1, y_1, z_1, x_2, y_2, z_2)

    l = self.calculate_distance(l_x, l_y, l_z)

    S_e = (E * A / (l**2)) * np.array([[-l_x, -l_y, -l_z, l_x, l_y, l_z]])

    return S_e

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 84
@patch
def create_internal_force_matrice_in_df(self: DirectStiffnessMethod, row):
    E = row["Modulus_of_elasticity"]
    A = row["Cross-sectional_area"]
    x_1 = row["x_1"]
    y_1 = row["y_1"]
    z_1 = row["z_1"]
    x_2 = row["x_2"]
    y_2 = row["y_2"]
    z_2 = row["z_2"]

    S_e = self.create_internal_force_matrice(
        E, A, x_1, y_1, z_1, x_2, y_2, z_2
    )
    return S_e

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 85
@patch
def create_internal_force_matrices(self: DirectStiffnessMethod):
    self.bars_extended["Internal_force_matrice"] = self.bars_extended.apply(
        self.create_internal_force_matrice_in_df, axis=1
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 91
@patch
def calculate_normal_force_in_df(self: DirectStiffnessMethod, row):
    degrees_of_freedom = np.concatenate(
        (row["Degrees_of_freedom_1"], row["Degrees_of_freedom_2"])
    )
    N = row["Internal_force_matrice"] @ self.u_f[degrees_of_freedom]
    return N[0]

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 92
@patch
def calculate_normal_force(self: DirectStiffnessMethod):
    self.bars_extended["Normal_force"] = self.bars_extended.apply(
        self.calculate_normal_force_in_df, axis=1
    )

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 103
@patch
def create_displacment_df(self: DirectStiffnessMethod):
    self.dimensions_names = ["X", "Y", "Z"]
    for index, name in enumerate(self.dimensions_names):
        self.nodes[f"Displacement_{name}"] = self.u_f[
            index :: self.dimensions
        ]

    self.translational_names = [
        "Translational_X",
        "Translational_X",
        "Translational_X",
    ]
    self.displacment_df = self.nodes[
        ~(self.nodes[self.translational_names].all(axis=1))
    ]

    self.displacment_df = self.displacment_df[
        ["Node", "Displacement_X", "Displacement_Y", "Displacement_Z"]
    ]

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 107
@patch
def create_force_df(self: DirectStiffnessMethod):
    for index, name in enumerate(self.dimensions_names):
        self.nodes[f"Force_{name}"] = self.F_f_corrected[
            index :: self.dimensions
        ]

    self.force_df = self.nodes[
        (self.nodes[self.translational_names].all(axis=1))
    ]

    self.force_df = self.force_df[["Node", "Force_X", "Force_Y", "Force_Z"]]

# %% ../nbs/03_Private_Modules/06_direct_stiffness_method.ipynb 110
@patch
def create_normal_force_df(self: DirectStiffnessMethod):
    self.normal_force_df = self.bars_extended[
        ["Bar", "Normal_force"]
    ].copy()
    self.normal_force_df["Type_of_normal_force"] = self.normal_force_df[
        "Normal_force"
    ].apply(
        lambda x: "Tensile force"
        if x > 0
        else ("Compressive force" if x < 0 else "Zero-force")
    )
