# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_Private_Modules/07_calfem.ipynb.

# %% auto 0
__all__ = ['CALFEMException', 'CALFEM']

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 2
# Copyright Â© 2023-2024  IfcTruss Contributors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 5
from fastcore.basics import patch
import numpy as np
import pandas as pd

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 6
try:
    import calfem.core as cfc
except ImportError:
    pass

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 7
class CALFEMException(Exception):
    pass

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 8
class CALFEM:
    def __init__(
        self,
        *,
        bars,
        nodes,
        point_loads,
    ):
        # copied from DirectStiffnessMethod class
        self.bars = bars
        self.nodes = nodes
        self.point_loads = point_loads

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 13
@patch
def extend_nodes_df(
    self: CALFEM,
):
    # copied from DirectStiffnessMethod class
    self.number_of_rows = self.nodes.shape[0]
    self.dimensions = 3

    self.number_of_degrees_of_freedom = (
        self.number_of_rows * self.dimensions
    )

    self.nodes["Degrees_of_freedom"] = pd.Series(
        np.split(
            np.arange(self.number_of_degrees_of_freedom),
            self.number_of_rows,
        )
    )

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 16
@patch
def extend_bars_df(
    self: CALFEM,
):
    # copied from DirectStiffnessMethod class
    start_node = self.nodes.rename(
        columns={
            "Node": "Start_node",
            "Coordinate_X": "x_1",
            "Coordinate_Y": "y_1",
            "Coordinate_Z": "z_1",
            "Degrees_of_freedom": "Degrees_of_freedom_1",
        }
    )

    bars_start = pd.merge(
        self.bars,
        start_node[
            ["Start_node", "x_1", "y_1", "z_1", "Degrees_of_freedom_1"]
        ],
        on="Start_node",
    )

    end_node = self.nodes.rename(
        columns={
            "Node": "End_node",
            "Coordinate_X": "x_2",
            "Coordinate_Y": "y_2",
            "Coordinate_Z": "z_2",
            "Degrees_of_freedom": "Degrees_of_freedom_2",
        }
    )

    self.bars_extended = pd.merge(
        bars_start,
        end_node[["End_node", "x_2", "y_2", "z_2", "Degrees_of_freedom_2"]],
        on="End_node",
    )

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 19
@patch
def create_element_stiffness_matrice(self: CALFEM, row):
    ex = row[["x_1", "x_2"]]
    ey = row[["y_1", "y_2"]]
    ez = row[["z_1", "z_2"]]
    ep = [row["Modulus_of_elasticity"], row["Cross-sectional_area"]]
    K_e = cfc.bar3e(ex, ey, ez, ep)

    return K_e

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 20
@patch
def create_element_stiffness_matrices(
    self: CALFEM,
):
    self.bars_extended["Element_Matrice"] = self.bars_extended.apply(
        self.create_element_stiffness_matrice, axis=1
    )

    self.bars_extended["Degrees_of_freedom"] = self.bars_extended.apply(
        lambda row: np.concatenate(
            (row["Degrees_of_freedom_1"], row["Degrees_of_freedom_2"])
        ),
        axis=1,
    )

    self.element_stiffness_matrices_df = self.bars_extended[
        ["Bar", "Element_Matrice", "Degrees_of_freedom"]
    ]

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 24
@patch
def create_system_stiffness_matrice(
    self: CALFEM,
):
    self.K_f = np.zeros(
        (
            self.number_of_degrees_of_freedom,
            self.number_of_degrees_of_freedom,
        )
    )

    for element_matrice, degrees_of_freedom in zip(
        self.element_stiffness_matrices_df["Element_Matrice"],
        self.element_stiffness_matrices_df["Degrees_of_freedom"],
    ):
        cfc.assem(degrees_of_freedom + 1, self.K_f, element_matrice)

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 27
@patch
def create_force_vector(
    self: CALFEM,
):
    # copied from DirectStiffnessMethod class
    self.F_f = np.zeros(self.number_of_degrees_of_freedom)

    self.point_loads_extended = pd.merge(
        self.point_loads,
        self.nodes[["Node", "Degrees_of_freedom"]],
        on="Node",
    )

    np.add.at(
        self.F_f,
        np.concatenate(
            self.point_loads_extended["Degrees_of_freedom"].values
        ),
        np.concatenate(
            self.point_loads_extended[
                ["Force_X", "Force_Y", "Force_Z"]
            ].values
        ),
    )

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 30
@patch
def calculate_displacement_vector_and_calculate_force_vector(
    self: CALFEM,
):
    self.degrees_of_freedom = (
        np.concatenate(
            self.nodes[
                [
                    "Degrees_of_freedom",
                ]
            ].values.flatten()
        )
        + 1
    )

    self.translationals = np.logical_not(
        self.nodes[
            [
                "Translational_X",
                "Translational_Y",
                "Translational_Z",
            ]
        ].values.flatten()
    )
    self.bc = self.degrees_of_freedom[~self.translationals]

    # Point Load in support are zero for the following calculation
    F = self.F_f.copy()
    F[~self.translationals] = 0

    try:
        self.u_f, self.F_f_calculated = cfc.solveq(
            self.K_f,
            F.reshape((self.number_of_degrees_of_freedom, 1)),
            self.bc,
        )
    except np.linalg.LinAlgError as l:
        if str(l) == "Singular matrix":
            raise CALFEMException("Mechanism - The system is unstable")
        else:
            raise l
    self.u_f = np.array(self.u_f).reshape(self.number_of_degrees_of_freedom)

    self.F_f_calculated = np.array(self.F_f_calculated).reshape(
        self.number_of_degrees_of_freedom
    )

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 36
@patch
def correct_force_vector(
    self: CALFEM,
):
    self.F_f_nodes = self.F_f.copy()
    self.F_f_nodes[self.translationals] = -self.F_f_nodes[
        self.translationals
    ]

    self.F_f_corrected = self.F_f_calculated - self.F_f_nodes

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 40
@patch
def calculate_normal_force_in_df(self: CALFEM, row):
    ex = row[["x_1", "x_2"]]
    ey = row[["y_1", "y_2"]]
    ez = row[["z_1", "z_2"]]
    ep = [row["Modulus_of_elasticity"], row["Cross-sectional_area"]]
    degrees_of_freedom = row["Degrees_of_freedom"]
    ed = cfc.extractEldisp(
        degrees_of_freedom + 1,
        self.u_f.reshape((self.number_of_degrees_of_freedom, 1)),
    )

    N = cfc.bar3s(ex, ey, ez, ep, ed)
    return N[0][0]

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 41
@patch
def calculate_normal_force(self: CALFEM):
    # copied from DirectStiffnessMethod class
    self.bars_extended["Normal_force"] = self.bars_extended.apply(
        self.calculate_normal_force_in_df, axis=1
    )

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 47
@patch
def create_displacment_df(self: CALFEM):
    # copied from DirectStiffnessMethod class
    self.dimensions_names = ["X", "Y", "Z"]
    for index, name in enumerate(self.dimensions_names):
        self.nodes[f"Displacement_{name}"] = self.u_f[
            index :: self.dimensions
        ]

    self.translational_names = [
        "Translational_X",
        "Translational_X",
        "Translational_X",
    ]
    self.displacment_df = self.nodes[
        ~(self.nodes[self.translational_names].all(axis=1))
    ]

    self.displacment_df = self.displacment_df[
        ["Node", "Displacement_X", "Displacement_Y", "Displacement_Z"]
    ]

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 50
@patch
def create_force_df(self: CALFEM):
    # copied from DirectStiffnessMethod class
    for index, name in enumerate(self.dimensions_names):
        self.nodes[f"Force_{name}"] = self.F_f_corrected[
            index :: self.dimensions
        ]

    self.force_df = self.nodes[
        (self.nodes[self.translational_names].all(axis=1))
    ]

    self.force_df = self.force_df[["Node", "Force_X", "Force_Y", "Force_Z"]]

# %% ../nbs/03_Private_Modules/07_calfem.ipynb 53
@patch
def create_normal_force_df(self: CALFEM):
    # copied from DirectStiffnessMethod class
    self.normal_force_df = self.bars_extended[
        ["Bar", "Normal_force"]
    ].copy()
    self.normal_force_df["Type_of_normal_force"] = self.normal_force_df[
        "Normal_force"
    ].apply(
        lambda x: "Tensile force"
        if x > 0
        else ("Compressive force" if x < 0 else "Zero-force")
    )
